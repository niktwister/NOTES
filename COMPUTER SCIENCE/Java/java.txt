
********************************************************************************************************
                                            javac
********************************************************************************************************

javac command will compile the source file (.java) and generate its corresponding class file (.class)(bytecode)

searching for  types
--------------------
https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html#BHCJJJAJ
    To compile the input <source file> specified on the command line , the compiler often needs information 
about a type referenced in the input <source file>, but the type definition may not be in the input <source file>. 
The compiler needs type information for every class or interface used, extended, or implemented in the input
<source file>. This includes classes and interfaces not explicitly  mentioned in the input <source file>, but 
that provide information through inheritance.

When the compiler needs type information for the type  referenced (explicitly  or  implicity through inheritance) 
in the input <source file>, it searches for a source file or class file that defines the type. The compiler 
searches for class files first in the bootstrap and extension classes, then in the user class path. The user 
class path is defined by setting the CLASSPATH environment variable or by using the -classpath option.

If ( -classpath option is provided ) then , 
    class path(s) = argument provided with -classpath option
Else if ($CLASSPATH env variable is set)  then ,
    class path(s) = $CLASSPATH
Else ,
    class path = current directory

    If the -sourcepath option is provided , then compiler searches the indicated path(s) for the source file 
of the types  referenced (explicitly  or  implicity through inheritance) in the input <source file>. If not then,
the compiler searches the  user class path for both class files and source files of the type.

    A successful type search may produce a class file, a source file, or both. If both are found, then you can
use the -Xprefer option to instruct the compiler which to use. If "newer" is specified, then the compiler uses
the newer of the two files. If "source" is specified, the compiler uses the source file. The default is "newer".

    If a type search finds a source file for a required type, either by itself, or as a result of the setting
for the -Xprefer option, then the compiler reads the source file to get the information it needs. By default 
the compiler also compiles the source file. You can use the -implicit option to specify the behavior. If "none" 
is specified, then no class files are generated for the source file. If "class" is specified, then class files
are generated for the source file.


javac [options] <source file>

options :

-d <directory> 
    specifies the location where the generated class file for the input <source file> will be placed.

--class-path <path> ,  -classpath <path>  , -cp <path>  
    specifies the path(s) where the compiler will look for the class files of the types  referenced (explicitly  
    or  implicity through inheritance) in the input <source file>.
    Multiple paths can be provided by separating them with ":" . 

    NOTE: Consider a class called "Example" . Suppose that its fully qualified name is :
                                        "some.dummy.Example"     // i.e., it's part of a package 
          
          If we want to reference this class in our <source file> through its class file "Example.class" then, 
          first of all Example.class should also exist in a similar directory structure as indicated by its 
          fully qualified name :
                                        some/
                                         |
                                         --- dummy/
                                               |
                                               --- Example.class

          while looking for Example class's class file , compiler will look for : 
                            some/dummy/Example.class , rather than just Example.class
         
          Immediate parent directory of some/ folder should be one of the classpath(s). 

-implicit:{none,class} 
    specifies whether or not to generate class files for implicitly referenced files.

--source-path <path>, -sourcepath <path>
    specifies where to look for the source files of the types  referenced (explicitly  or  implicity through 
    inheritance) in the input <source file>.
    Multiple paths can be provided by separating them with ":" . 

    NOTE: Consider a class called "Example" . Suppose that its fully qualified name is :
                                        "some.dummy.Example"     // i.e., it is part of a package 
          
          If we want to reference this class in our <source file> through its source file "Example.java" then, 
          first of all Example.java should also exist in a similar directory structure as indicated by its 
          fully qualified name :
                                        some/
                                         |
                                         --- dummy/
                                               |
                                               --- Example.java

          while looking for Example class's source file , compiler will look for : 
                            some/dummy/Example.java , rather than just Example.java
         
          if -sourcepath is not provided then , immediate parent directory of some/ folder should be one of the
          classpath(s)  , or if -sourcepath is provided then , immediate parent directory of some/ folder should 
          be one of the sourcepath(s). 


-Xprefer:{source,newer}
        Specify which file to read when both a source file and class file are found for a type  referenced 
        (explicitly  or  implicity through inheritance) in the input <source file>.


NOTE : The JVM ("java" cmd) only looks for class files of the referenced types and not the source files. It
       searches for the class files (including the input <class file>) in the classpath(s).

       The java compiler ("javac" cmd) on the other hand looks for both the class files and source files of 
       the referenced types. But "javac" cmd requires absolute or relative path to the input <source file>  
       , DO NOT ASSUME that if you have provided the -sourcepath option then javac will also look for the 
       input <source file> in one of the sourcepath(s)!!!! 
       


********************************************************************************************************
********************************************************************************************************

A java <source file> can contain multiple classes but only one of them can be public , and the name of
the <source file> should be same as the name of the public class.
If a <source file> does not contain a public class then , it can have any name.

This rule eases up the compiler <source code> lookup process for a class. For example , if compiler is 
looking for the source code of a public class called "Person" , then compiler will know for sure  that
the source file containing this public class will be called "Person.java".
Thus compiler fill first check the source file's name, if it doesn't match the class it is looking for 
then it won't read that source file.  
This approach work well for a public class but not so much for a default access class which may exist in 
a source file not named after it. Thus  compiler may  or may not  find a default access class , throwing
error if it doesn't.

