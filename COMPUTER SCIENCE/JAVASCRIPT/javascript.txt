Two types of comments in JS :

    //  this is  a single line comment

    /*  this is a multiline
        comment     */


Identifiers can begin with either an â€˜_â€™ , â€˜$â€™ , or a letter. The subsequent characters can be letters , 
digits , â€˜$â€™ , â€˜_â€™ .

Many reserved words canâ€™t be used as names for variables , constants , function or classes. But can be used 
as a property within an object. (like : if / else / while / do / for / function / switch / class / â€¦)
    >> let obj = {};
    >> obj.if = 23;     // OK

Reserved words scenario is a little complicated in JS . For eg: "let" is allowed to be used as an identifier 
when declared with "var" , but not allowed when declared with "const" or inside a class. 

    >> var let = 23 ;  // OK   // it is allowed because of backward compatibility issue


AUTOMATIC SEMICOLON INSERTION
-----------------------------
    https://www.bradoncode.com/blog/2015/08/26/javascript-semi-colon-insertion/


    We have an option in JS to not put a (;) at the end of a statement even if its grammar rule requires 
    you to do so. For example ,
            var a			same as , 	    var a;
            b = 23						    b = 23;

    The compiler will automatically insert a semicolon there (not literally though!). Compiler not gonna change 
    your source code , it will just pretend as if that location contains a (;).

    This whole drama is just so that JS can distinguish one statement from another , and it sometimes leads to 
    unexpected behaviour.

    There are 3 rules and 2 overriding exceptions that governs its working.

    NOTE :  A Token is the smallest element of a program that is meaningful to the compiler( keywords , 
            identifiers , constants , special symbols , operators ).

            Example of a grammar rule :
            Grammar rule for return statement looks like:  return [no LineTerminator] <exp>;


    RULE 1
    ------
        When reading tokens of a program from left to right , a token that doesnâ€™t match a grammar rule 
        has a semicolon inserted before it if either of the following conditions are met :
            1. The error token is separated from the previous token , by at least one line terminator.
            2. The error token is }.

    
        (1) basically means that if the first token on the next line appears to be in continuation of the 
        grammar rule from the current line , then (;) will not be inserted .If not , then it will be 
        inserted. 

        Example , 		var a 			becomes,			var a;
                        var b						    	var b
        (;) is inserted on line 1 because "var a var" wouldnâ€™t be in continuation of the grammar rule for 
        variable declaration of line 1. 


        Example,		var a 			same as ,			var a = 3 ;
                        =
                        3
        No (;) was inserted on line 1 or line 2 because they all seem to be in continuation of the grammar 
        rule for variable declaration of line 1.



        Example for (2) condition ,
                {return 3}			will become ,		{return 3;}
        The grammar rule for the return statement was expecting a (;) after 3 , but instead it got }.  Hence 
        } becomes the error token and a (;) was inserted before it.


    RULE 2
    ------
        If the program is parsed until the end of the input (meaning that we have reached the end of file) 
        and it is not yet a complete program , then a (;) is inserted at the end of file.

        Example , suppose test.js consist of following two lines only :
            var a = 3;
            a++

        Then a (;) will automatically be inserted at the EOF if required , in order to complete the program :
            var a = 3;
            a++;

        NOTE :  Please note that only the statement whose grammar rule requires a (;) for termination is 
                affected by ASI :-
                empty	    	variable declaration	expression		do-while
                continue		break					return			throw

        Statements like if , while , for , do not require termination by (;) in their grammar rule , and 
        hence are unaffected by ASI.


    RULE 3
    ------
        For the following grammar rules that do not allow line terminators where indicated , if a line 
        terminator is encountered , parser will try to save you by adding a semicolon before the first 
        encountered line terminator.

            Postfix expression:
	            LHSExpression [no LineTerminator] ++
	            LHSExpression [no LineTerminator] --

            Continue statement :
	            continue [no LineTerminator] identifier;

            Break statement :
                break [no LineTerminator] identifier;

            Return statement :
                return [no LineTerminator] <exp>;

            Arrow functions :
                arrowParameters [no LineTerminator] =>  conciseBody

        Example , 

            return 			will become , 			return ;
            {									{
                a: 23									a: 23
            }									}



        Example ,

            a				will become , 			a ;
            ++			    						++c ;
            c


    TWO EXCEPTIONS THAT OVERRIDE THE ABOVE RULES
    --------------------------------------------

        1)  A (;) is never inserted automatically inside the header of a for statement.

                for(expression   ;   expression   ;   expression)
            
                        These two semicolons have to be inserted manually and are
                        also compulsory . ASI wonâ€™t work inside the header of for.

        2) A (;) is never automatically inserted if doing so results in an empty statement.

                Example , 

                suppose last line of our program is this ,
                        for(var i=0 ; i < 10 ; ++i)

                Then according to rule #2 , a (;) should have been inserted after it , in order to 
                complete the program. But since doing so would result in an empty statement ,
                hence JS wonâ€™t do it , thus resulting in an error.



There are 6 primitive types in Javascript :
    number
    string
    boolean
    null
    undefined
    symbol


Everything else is an object. (Even functions are objects) (Even classes are special functions which in turn 
make them objects!!)

JS primitive types are immutable and all the objects are mutable.

NOTE : ES2020 introduced a new primitive type called "bigint".


IN JS all numbers (integer or floating point) are represented using IEEE 754 64 BIT STANDARD.

    Number.MAX_VALUE = 1.7976.. x 10^(+308)
    Number.MIN_VALUE = 5 x 10^(-324)

    Number.MAX_SAFE_INTEGER = 2^(53) - 1
    Number.MIN_SAFE_INTEGER = - (2^(53) - 1)


Please note that certain operations such as "array indexing" and "bitwise operations" are performed using
32 bit integers.

Some example of integer literals :

    35                  // base 10
    0xA1F               // base 16
    0b1011              // base 2
    0o1073 or 01073     // base 8

Floating point literals may also be represented by exponential notation ,
	[digits][.digits][(E|e)[(+|-)]digits]		example ,  55.35e-5



SPECIAL VALUES IN JAVASCRIPT
----------------------------

    Interestingly JS does not raise an error in case of overflow or underflow or even division by 0.

    1)  Infinity , - Infinity
        ---------------------

        When result of an operation > Number.MAX_VALUE , JS returns a predefined global constant called 
        Infinity.

        Similarly , when result of an operation  <  - Number.MAX_VALUE   ,  JS returns   - Infinity.

        1 / 0								// Infinity
        Number.MAX_VALUE * 2				// Infinity
        Number.POSITIVE_INFINITY			// same as Infinity
        - 1 / 0							    // - Infinity
        - Number.MAX_VALUE * 2			    // - Infinity
        Number.NEGATIVE_INFINITY			// same as - Infinity


    2)  + 0  ,  - 0
        -----------

        Let [result] be the result of an operation.

        If   0  <  [result]  <  Number.MIN_VALUE   ,   then JS will return  + 0.

        If   - Number.MIN_VALUE  <  [result]  <  0   ,  then JS will return - 0.


        Number.MIN_VALUE / 2			// + 0
        - Number.MIN_VALUE / 2		    // - 0
        1 / Infinity					// + 0
        -1 / Infinity					// - 0



    3)  NaN
        ---

        NaN is a predefined global constant which is returned as a result of an operation in two cases :

            1.	When the outcome is indeterminate.	âˆž / âˆž  ,  0 / 0 , âˆš-1 

            2.  When at least one of the operands cannot be converted into a number in an arithmetic operation.
		            >>  undefined + 3
		                NaN

        0 / 0					// NaN
        Infinity / Infinity		// NaN
        Math.sqrt(-1) 			// NaN


        There is an interesting fact about NaN , it does not compare equal to any other value , including 
        itself.
        i.e., 		NaN === NaN		// false
		        	NaN !=  NaN		// true

        Thus to check if a variable x is NaN or not , we can do two things :
            x != x
            isNaN(x)



        + 0 and - 0 are equal i.e., +0 === -0  returns true.
        1/0  ===  -1/0    returns false  ,  since  1/0 evaluates to Infinity and  -1/0  evaluates to -Infinity.



BigInt
------

    ES2020 introduced a new primitive type "bigint" that can be used for integers of ANY size.

    bigint literals can be formed by appending integer literals with "n".
    Example , 	9007199254740993n
                -35789000085764994321n
                0x23af51aan				// hexadecimal bigint
                0b10110001101000011n	// binary
                0o45n   or,  045n		// octal
                
    >> typeof 3581n
    â€œbigintâ€

    There is no limit to the size of integers that can be stored using bigint.

    Just as the "number" primitive type has a corresponding wrapper class "Number" , "bigint" also has a 
    corresponding wrapper class called "BigInt".

    BigInt can be used as a function to convert integer and string literals into bigint literals. 
    (class is just a special type of function in Javascript).
    >>  BigInt(1245)			>>  BigInt(â€œ987654321â€)
        1245n						987654321n


    Please note that unlike Number , we cannot use the new operator to create a BigInt object.
						new BigInt()		// ERROR

    We can instead do this  :	
        >>  let ob = new Object(347n)	// OK
        >>  ob.constructor.name
            'BigInt'

    bigint literals can also use the following operators :	+  ,   -   ,   *   ,   /   ,   **   ,   %
    >>  50n + 60n
        110n

    >>  2n ** 45n
        35184372088832n

    >>  5n / 2n			// â€˜/â€™ operator will round off towards 0 in case of bigint
        2n

    >>  -3n / 2n
        -1n


    bigint literals cannot be mixed with number literals in all the above operations.
    >> 5n + 5
    TypeError : cannot mix BigInt and other types , use explicit conversions.



    bigint literals cannot be passed to the Math object methods :
    >> Math.sqrt(25n)
    TypeError


    Unlike arithmetic operators , bigint literals and number literals CAN BE compared using comparison 
    operators :
    >>  10n > 5
        true

    >>  2n > 2
        false

    bigint literal and number literal with the same value are loosely equal but strictly unequal.
    >>  5n == 5		// only checks value
        true

    >>  5n === 5		// checks value and type
        false


"string" primitive type
-----------------------

    Javascript uses UTF-16 encoding of unicode. i.e., strings in JS are sequence of 16-bit values.

    Eg :                                "Hello"
                                           |
                   H           e           l           l           o        
                .......     .......     .......     .......     .......
                |00 48|     |00 65|     |00 6C|     |00 6C|     |00 6F|         [BIG ENDIAN]
                ```````     ```````     ```````     ```````     ```````
                U+0048      U+0065      U+006C      U+006C      U+006F

    But as we know , if a string contains a char from astral planes , then that char will be stores as a
    pair of two 16-bit values (4 bytes).

                                        "IðŸ’™U"
                                        /  |  \
                                       /   |   \
                           |```````````    |    ```````````|
                        .......     ....... .......     .......        
                        |00 49|     |D8 3D| |DC 99|     |00 55|     [BIG ENDIAN]
                        ```````     ``````` ```````     ```````
                        U+0049          U+1F499         U+0055

    

    -> "\uWWXX" :   A char in BMP that will be stored in memory as ,
                    .......
                    |WW XX|     [BIG ENDIAN] 
                    ```````
                    .......
                    |XX WW|     [LITTLE ENDIAN]
                    ```````
                    but will always be read as  WW XX

        "\uWWXX\uYYZZ"  :   A char in astral planes that will be stores in memory as ,
                            ....... .......
                            |WW XX| |YY ZZ|     [BIG ENDIAN]
                            ``````` ```````
                            ....... .......
                            |XX WW| |ZZ YY|     [LITTLE ENDIAN]
                            ``````` ```````
                            but will always be read as ,  WW XX  YY ZZ 

        Hence "Hello" is same as : "\u0048\u0065\u006C\u006C\u006F"

        and "IðŸ’™U" is same as : "\u0049\uD83D\uDC99\u0055"

        Clearly , remembering a char's bit representation is a little too much especially for
        characters from astral planes where there is no visible correlation b/w character's 
        codepoint and character's bit representation.

        So JS ES6(2015) introduced another escape sequence "\u{codepoint}" where we can just 
        use the character's codepoint(in hex) to get the character.
        Eg :
               we can print "ðŸ’™" as "\u{1F499}" , which will be same as "\uD83D\uDC99".


    ->  strings can be enclosed in "double quotes" or 'single quotes' or `back ticks`   

    ->  It is not allowed to break a string across multiple lines when using ".." or '..' ,
        but allowed when using `..` . For example :

        let str = " my name is 
                    Nikunj Pathak and           // This will throw syntax error
                    I would love to talk "       

        let str = ` my name is 
                    Nikunj Pathak and           // This is OK , but will preserve the EOL in the string
                    I would love to talk ` 

        We can (\) operator to break string across multiple lines such that neither (\) or EOL will
        be included in the string. It can be used with ".." or '..' or `..`

        let str = " my name is \
                    Nikunj Pathak and  \         
                    I would love to talk "  // Every line should end with (\) except the last one.

    ->  str.length will calculate the number of 16-bit values in str.
        Example ,       "IðŸ’™U".length === 4     // true

        strings can be compared using === and !== , two strings will be equal if and only id they
        consist of exactly the same sequence of 16-bit values.

        strings can also be compared with (<) , (<=) , (>) , (>=) . Comparision is done simply by 
        comparing the 16-bit values.

        str[i] : character corresponding to the ith 16-bit value in str


    methods of the "String" wrapper class
    -------------------------------------

        let str be an object of String class.
        If str is a primitve string then it will be wrapped inside a String object before these methods
        are called.

        str.substring(i,j)  :   substring from ith 16-bit value to jth 16-bit value

        str.split(delimiter)    :   split the str using the delimiter provided and returns an array.

        str.indexOf(substr) :   position of 1st occurence of substr in str. 
                                returns -1 if substr not found in str.
        
        str.replace(s1,s2)  :   returns a new string by replacing 1st occurence of s1 in str , by s2.

        str.replaceAll(s1,s2)   :   returns a new string by replacing all occurrences of s1 in str by s2.

        str.toLowerCase()   // will return a new string 
        str.toUpperCase()   // will return a new string

        str.charAt(i)   :   returns the char corresponding to ith 16-bit value in str , same as str[i]

        str.codePointAt(i)  :   returns the decimal value of the codepoint of the actual ith character
                                of the string str , rather than the character corresponding to the ith 
                                16-bit value.
                                Example,        >>  "IðŸ’™U".codePointAt(1)
                                                    128153                  // 0x1F499

        String.fromCodePoint(codepoint) :   A static method
                                            Takes the codepoint(dec) of a unicode char , and returns the
                                            character.
                                            Example ,   >>  String.fromCodePoint(128153)
                                                            "ðŸ’™"

    
    ->  If the string contains non-BMP characters , then there is no point in iterating through the string
        using str.charAt(i) / str[i] inside a "for" loop. Because they will iterate through the 16-bit
        values.

        We should rather use "for/of" loop which will iterate through the actual characters of the string
        and not the 16-bit values.
            for(let ch of str){
                console.log(ch)
            }

    TEMPLATE LITERAL
    ----------------

        we can evaluate expressions within a string quoted with `..`

                `I am evaulating an ${expression} inside this string`
        
        Example,
            let name = "nikunj";
            let age = 23;

            console.log(`My name is ${name} and I am ${age} yrs old.`);

    
    NORMALIZATION
    -------------

        >>  let e1 = "\u00E9"           // eÌ
        >>  let e2 = "\u0065\u0301"     // eÌ

        >>  e1
            eÌ
        >>  e2
            eÌ
        >>  e1 === e2
            false

        As we see , both e1 and e2 print same accented "e" (eÌ) , but still they are not equal , since
        they are formed with diff sequences of 16-bit values.
        
        Thus sometimes the same char can be formed in multiple ways , which is problematic , since on
        surface two texts might appear same but turn out to be different internally.

        The process of removing such ambiguities is called normalization of text , in which all the 
        equivalent sequences of 16-bit values are replaced by some default sequence of 16-bit values.
        For example , in above case if we normalize e2 , then  \u0065\u0301   will be replace with 
        \u00E9  .

        JS doesn't perform normalization on its own , but ES6 provide a string class method normalize() :
            >>  e1 === e2.normalize()
                true



SYMBOL
------

    "symbol" is a primitve type introduced in ES6.

    symbol primitive type has a corresponding wrapper class called "Symbol" , which we can be used as a 
    function to get a primitive symbol value. Indeed it is the only way to create a symbol.

        let sym = Symbol();

    We can pass a string to Symbol() , which will act as a descriptor for the primitive symbol value 
    created. (This is useful for debugging and doesnâ€™t serve any other purpose and definitely has no 
    say whatsoever in how the symbol value will be generated internally)

        >>  let sym = Symbol("id")
        >>  sym
            Symbol(id)
        >>  sym.description
            "id"
        
    ->  The special fact about symbol is that whenever it is generated by calling the Symbol() function ,
        a unique primitive symbol value will be returned each time.

            >>  let sym1 = Symbol()
            >>  let sym2 = Symbol()
            >>  sym1 === sym2
                false

        Even when thet have same descriptor :

            >>  let sym1 = Symbol("id")
            >>  let sym2 = Symbol("id")
            >>  sym1 === sym2
                false

    

    ->  Just like "BigInt" wrapper class , we cannot use "new" to create a Symbol class object. 

        We can instead do this  :
            >>  let sym = Symbol()	
            >>  let ob = new Object(sym)	// OK
            >>  ob.constructor.name
                'Symbol'



    ->  objects in JS are basically collection of (key,value) pairs. Before symbol(s) were introduced in ES6 ,
        keys were only allowed to be of type string. But now (along with string) we can also use symbol(s) as
        keys.
        Example :
            >>  let id = Symbol("EMPID")
            >>  let obj = {
                name : "nik" ,
                age : 23 ,
                gender : "m"
            }

            >> obj[id] = 6080602    //  using symbol as a key
                                    //  please note that we cannot use dot notation (obj.key) if key is a symbol
                                    //  always use bracket notation (obj[key])

            >>  obj
                age : 23
                name : "nik"
                gender : "m"
                Symbol(EMPID) : 6080602
            
        We can do the same thing while creating object literal :

            >>  let id = Symbol("EMPID")
            >>  let obj = {
                name : "nik" ,
                age : 23 ,
                gender : "m" ,
                [id] : 6080602
            }
            >>  obj
                age : 23
                name : "nik"
                gender : "m"
                Symbol(EMPID) : 6080602


    ->  Using symbols as keys in objects is their primary purpose infact.

        Suppose we are using a 3rd party library in our code which provide us an object called "user".
        Now let us suppose we want to add an "id" property in "user". Should we use a "string as the key"
        or "a symbol as the key" for this property ??

        If we use the string "id" as the key for this property , then how do we know that there isn't already
        a property with string key "id" ?? In which case we will just be overriding an existing property and
        eventually causing the library to malfunction.

        But instead if we use a symbol as the key , there won't be any conflict with any existing property
        because :
            (1) It won't conflict with any string keys (since its of type symbol)
            (2) It won't conflict with other symbol keys , since every symbol is unique at runtime.

        Hence while creating a property for an object from some 3rd party library , we should use symbol(s)
        as the keys to avoid conflict with any existing property.

    
    ->  symbolic properties of an object are somewhat "hidden" in many ways.

        >>  let user = {
                name :"nikunj",
                age : 27,
                sex : "m",
                [Symbol("id")] : 6080602
        }

        >>  Object.getOwnPropertyNames(user)    // symbol properties won't appear in the o/p of this method
            ["name","age","sex"]
        
        >>  Object.keys(user)   //  symbol properties won't appear in the o/p of this method
            ["name","age","sex"]
        
        >>  for(let key in user)    // symbolic properties are skipped in for...in loop
                console.log(key);
            name
            age
            sex
        
        >>  JSON.stringify(user)    // symbolic porperties are skipped here also
            "{"name":"nikunj","age":23,"sex":"m"}"
        
        But they aren't completely hidden. We can use Object.getOwnPropertySymbols(..) to get an array
        of all the symbolic keys for the passed object.

            >>  Object.getOwnPropertySymbols(user)
                [Symbol(id)]


    global symbol registry
    ----------------------

        lets suppose we store a symbol in some variable. If  the  symbol exist only in  that particular
        variable then as  soon as that  variable is overwritten ,  the  unique symbol inside it will be
        gone forever.
            Thats why there exist a "global symbol registry" , where we can store a symbol by associating
        it  with  some descriptive string (called its key) and then later fetch it anywhere we want using
        that key.

        Symbol.for(key)     :   static method
                                Searches for existing symbol in the global registry with given key and 
                                returns it if found. Otherwise a new gets created in the registry with
                                the provided key.
        
        Symbol.keyFor(sym)  :   static method
                                If sym exist in global symbol registry then returns its key , otherwise
                                return undefined.
        
        >>  let sym = Symbol.for("fun")     //  will create a new symbol in global symbol registry 
                                            //  with key "fun"
        >>  Symbol.keyFor(sym)
            "fun"
        
        >>  let ob = {
                name : "nik",
                [sym] : Symbol("garbage")
        }

        >>  sym = null

        >>  ob[Symbol.for("fun")]   //  fetching existing symbol from registry with key "fun"
            Symbol(garbage)



->  Any javascript value can be converted to a boolean value.

    Only these 6 converts to false (they are called falsy values) :
        undefined
        null
        0
        -0
        ""
        NaN

    All other values (including any object reference) converts to true. They are called truthy values.



LOGICAL OPERATORS
-----------------

    1)  a || b

        If 'a' is a truthy value , then returns 'a'.
            >>  5 || 0      >>  10 || 15
                5               10

        Otherwise if 'a' is falsy value , then it returns 'b'.
            >>  undefined || null       >>  null || 5
                null                        5                


    2)  a && b

        If 'a' is a truthy value , then returns 'b'.
            >>  5 && 0      >>  10 && 15
                0               15

        Otherwise if 'a' is falsy value , then it returns 'a'.
            >>  undefined && null       >>  null && 5
                undefined                   null                


    3)  !(a)

        If 'a' is truthy value =>   return false
        If 'a' is falsy value   =>  return true



->  "undefined" is the return value of the function that does not return anything.
->  "undefined" is the value of function parameter for which no argument is passed.


TYPE CONVERSION IN JAVASCRIPT
-----------------------------

    PRIMITIVE-TO-PRIMITIVE CONVERSION
    ---------------------------------
        .....................................................................        
        |   value           |   to string   |   to number   |   to boolean  |
        .....................................................................        
        `````````````````````````````````````````````````````````````````````
        |   undefined       |   "undefined" |   NaN         |   false       |
        ---------------------------------------------------------------------
        |   null            |   "null"      |   0           |   false       |   
        ---------------------------------------------------------------------
        |   true            |   "true"      |   1           |               |
        ---------------------------------------------------------------------
        |   false           |   "false"     |   0           |               |
        ---------------------------------------------------------------------
        |   ""              |               |   0           |   false       |
        ---------------------------------------------------------------------
        |   "1.2"           |               |   1.2         |   true        |
        ---------------------------------------------------------------------
        |   "one"           |               |   NaN         |   true        |
        ---------------------------------------------------------------------
        |   0               |   "0"         |               |   false       |
        ---------------------------------------------------------------------
        |   -0              |   "0"         |               |   false       |
        ---------------------------------------------------------------------
        |   1               |   "1"         |               |   true        |
        ---------------------------------------------------------------------
        |   Infinity        |   "Infinity"  |               |   true        |
        ---------------------------------------------------------------------
        |   -Infinity       |   "-Infinity" |               |   true        |
        ---------------------------------------------------------------------
        |   NaN             |   "NaN"       |               |   false       |
        `````````````````````````````````````````````````````````````````````


    Functions in JS expects the values that they are receiving to be of certain type, and if they
    are not, then the function will convert those values to the required type before performing 
    any further operation. For exmaples :

        ->  alert()

            alert() function always expect value of type "string". Thus we pass it undefined , then
            it will first convert it to string i.e., "undefined".

        ->  * (multiplication operator)

            (*) expects both of its operands to be of type number. Thus we try to do (true*5) , then
            true will be first converted to 1 and thus 1*5 i.e., 5 will be returned.

            Similarly null*5 will return 0.

        ->  +   (plus operator) (binary operator)

            binary (+) is a little complicated , because it is used with strings for concatenation and
            also with numbers for addition.

            If even one of the operand is a string , then it will convert the other to string and 
            concatenates them. Otherwise , if none of the operands are string , then (+) will act
            like an arithmetic operator and will try to convert its operands into type number (if
            they are not already) and then add them.

            >>  "abc" + 50          >>  null + 10
                "abc50"                 10

            >>  null + true         >>  undefined + null
                1                       NaN

    If function receives primitive values then primitive to primitive conversion is done , but what
    will happen if we pass an object to the function ? This is where object-to-primitive conversion
    will come into play.

    But before looking into object-to-primitive conversion , we must familiarize ourself with two
    special methods toString() and valueOf().

    toString()
    ----------
        Apparently this is the method you're supposed to call if you want to convert an object to string.
        Every object will inherit this method from "Object" class. But we can override the inherited 
        implementation by our own implementation. (which is done by most of the built-in classes)

        consider the "Array" and "Date" built-in classes :
            >>  [1,2,3].toString()
                "1,2,3"
            
            >>  (new Date()).toString()
                'Wed Jul 27 2022 15:44:31 GMT+0530 (India Standard Time)'

        The toString() method inherited from "Object" class simply returns the string "[object Object]".
            >>  let ob = {}
            >>  ob.toString()
                '[object Object]'

        Implementing the toString() method :
            >>  let user = {
                    name : "nik",
                    age : 23,
                    toString : function(){
                        return `Hi!! I am ${this.name}. I am ${this.age} years old.`;
                    }
                }
            >>  user.toString()
                'Hi!! I am nik. I am 23 years old.'

    
    valueOf()
    ---------

        Just like toString() , valueOf() method is by default inherited from "Object" class but
        can be overriden by own implementation.

        Unlike toString() , its purpose is not very clear.

        The default valueOf() method (inherited from Object class) simply returns back the reference
        of the object on which it was called.
            >>  let ob = {a:23,b:34}
            >>  ob.valueOf() === ob
                true
        
        Array class also uses the inherited method :
            >>  let arr = [1,2,3]
            >>  arr.valueOf() === arr
                true
        
        Wrapper classes Number,String,Boolean implements valueOf() method to just return the value of
        the wrapped primitive :
            >>  let n = new Number(50)          >>  let s = new String("Hi")
            >>  n.valueOf()                     >>  s.valueOf()
                50                                  'Hi'

        Date class implements the valueOf() method to return the timestamp of the datetime represented
        by the Date object invoking the method :
            >>  let d = new Date()
            >>  d.valueOf()
                1658922390984

    
    OBJECT-TO-PRIMITIVE CONVERSION
    ------------------------------
        https://javascript.info/object-toprimitive

        When an object is to be converted to a primitive type , one of JS internal method known as 
        ToPrimitive(..) is called. This method is called automatically by many built-in functions 
        and operators that expect a primitive as a value. This method takes two arguments :
            1)  object to be converted
            2)  preferredType
        
        The second argument preferredType is suppose to be a string with one of these 3 possible values :
            
            1)  preferredType === "string"   (prefer-string)
                This means that it will be preferred if the object is converted to a string.
                alert() function uses this preferredType if it receives an object.

            2)  preferredType === "number" (prefer-number)
                This means that it will be preferred if the object is converted to a number.
                Most of the arithmetic operators such as (*)(-)(**) will use this preferredType when
                one of their operand is an object. Binary (+) is an exception.

            3)  preferredType is not passed (no preference)
                This means that there is no preference. The object is not expected to be of
                a particular primitive type after conversion.
                Binary operator (+) will do this if one of the operand is object , because
                (+) works with both string and number type.

        Please note that the type of primitive that the object will get converted to may or may
        not be what was preferred. For example a number primitive might be returned even if 
        ToPrimitive(..) was called with preferredType==="string". 
        Thus the internal function or operator calling the ToPrimitive(..) method may have to
        perfrom an additional primitive-to-primitive conversion , in order to get the correct
        type of primitive value before performing the operation.

        NOTE :  https://tc39.es/ecma262/#sec-type-conversion
                ToPrimitive(..) is implemented natively.
                primitive-to-primitive conversion is also performed by calling natively implemented
                internal methods :
                    ToBoolean(..)
                    ToNumber(..)
                    ToBigInt(..)
                    ToString(..)
                    ...

        implementation of ToPrimitive(..) method
        ````````````````````````````````````````
            def ToPrimitive(input,[preferredType]) :
                
                1.  ->  If preferredType is not passed  , set hint = "default".
                    ->  Else if preferredType is String , set hint = "string".
                    ->  Else if preferredType is Number , set hint = "Number".
                
                2.  ->  If there is a method on the input object with the key Symbol.toPrimitive , then :
                            a)  Call the method and pass the hint as first parameter.
                            b)  If the return value of this method is of primitive type , then 
                                return that value else throw TypeError.
                    
                    ->  Else if no such method with the key Symbol.toPrimitive exist on input object , then :
                            a)  If hint is "default" , set hint to "number".
                            b)  return OrdinaryToPrimitive(input,hint)

            
            def OrdinaryToPrimitive(input,hint) :

                1.  If hint === "string" , then let methods be a list ["toString","valueOf"].

                2.  If hint === "number" , then let methods be a list ["valueOf","toString"].

                3.  For each method in the list methods do :
                        a)  Call the method on the object if it exists.
                        b)  If the return value is primitive , then return that value.

                4.  Throw TypeError.    // implying neither toString nor valueOf returned a primitive value.

        
        Symbol.toPrimitive
        ``````````````````

            This is one of the many special symbols in JS which exist as the static property of the
            Symbol class.

            Using this Symbol , we can define a method [Symbol.toPrimitive](hint) in our object , 
            through which we can control the object-to-primitive conversion of our object.

            How? If we examine the ToPrimitive(..) method above , we will realize that before trying
            anything else , it checks if the object has a [Symbol.toPrimitive](hint) method or not.
            If yes then [Symbol.toPrimitive](hint) is called on the object for a primitive value ,
            else if not then ultimately other methods (toString,valueOf) are tried.

            Also note that if the method [Symbol.toPrimitive](hint) exist but returns a non-primitive
            value then TypeError is thrown.

            The parameter hint passed to the [Symbol.toPrimitive](..) method has 3 possible values :
                1)  hint === "number"
                    When preferredType passed to ToPrimitive is "number".
                
                2)  hint === "string"
                    When preferredType passed to ToPrimitive is "string".
                
                3)  hint === "default"
                    When no preferredType is passed to ToPrimitive.  

        
        examples of object-to-primitive conversion
        ``````````````````````````````````````````

        1)  >>  let user = {
                    name : "nik",
                    age : 23,
                    [Symbol.toPrimitive] : function(hint){
                        if(hint==="string")
                            return "my name is nik and i am 23 yrs old.";
                        else if(hint==="number")
                            return 23;
                        else if(hint==="default")
                            return "100";    
                    }
                }

            >>  alert(user)                             // alert() will call ToPrimitive(..) with 
                'my name is nik and i am 23 yrs old.'   // object = user and preferredType = "string".
                                                        // Which in turn will call 
                                                        // user[Symbol.toPrimitive](hint) with hint = "string".

            >>  user * 3    // (*) will call ToPrimitive(..) with object = user and preferredType = "number".
                69          // Which in turn will call user[Symbol.toPrimitive](hint) with hint = "number".
            
            >>  user + 5   // (+) will call ToPrimitive(..) with object = user and no preferredType is passed.
                           // Which in turn will call user[Symbol.toPrimitive](hint) with hint = "default".
                           // user[Symbol.toPrimitive](hint) will therefore return "100" which in turn will
                           // be returned by ToPrimitive(..) 
                           // "100" + 5 will then evaluate to "1005" , because as we know that if even one
                           // of the operand is a string , (+) will convert the other to string as well and
                           // concatenate them.


        2)  >>  let user = {
                    name : "nik",
                    age : 23,
                    [Symbol.toPrimitive] : function(hint){
                        if(hint==="string")
                            return "my name is nik and i am 23 yrs old.";
                        else if(hint==="number")
                            return 23;
                        else if(hint==="default")
                            return {};              // returning an object. 
                    }
                }

            >>  user + 10
                TypeError       //  Because [Symbol.toPrimitive](hint) will fail to provide a primitive 
                                //  value , since it will be called with hint === "default".

        
        3)  >>  let user = {
                    name : "nik",
                    age : 23,
                    toString : function(){
                        return {};
                    } ,
                    valueOf : function(){
                        return 23;
                    }
            }

            >>  alert(user) //  [Symbol.toPrimitive](..) doesn't exist for user and its toString fails
                "23"        // to provide a primitive vlue so valueOf(..) will be asked for primitive
                            // value. ToPrimitive(..) will return 23 to alert(..) , which will then 
                            // convert 23 to string i.e., "23".

            >>  user + 10     
                33          // Since ToPrimitive(..) wasn't passed a preferredType , hint was set to 
                            // "default". Since [Symbol.toPrimitive](..) doesn't exist , ToPrimitive(..)
                            // will call OrdinaryToPrimitive(..) with hint==="number". 
                            // OrdinaryToPrimitive(..) will first try to call valueOf() on user , which
                            // will return 23. Hence ToPrimitive(..) will in turn also return 23.
                            // 23 + 10 will evaluate to 33.

        
        4)  >>  [] * 67     //  ToPrimitive(..) will be called by (*) on [] with preferredType === "number".
                0           //  Array class does not define [Symbol.toPrimitive](..) , therefore ,
                            //  OrdinaryToPrimitive(..) will be called in turn with hint === "number."
                            //  OrdinaryToPrimitive(..) will call valueOf() on [] , which will return an
                            //  object reference i.e., not a primitive value. Therefore toString() will be 
                            //  called on [] next , which will return "" (empty string) i.e., a primitive.
                            //  Therefore OrdinaryToPrimitive(..) will return "" which in turn be returned
                            //  by ToPrimitive(..). 
                            //  Since "" is not a number , (*) will perform primitive-to-primitive conversion
                            //  by passing "" to ToNumber() , which will convert it to 0.
                            //  Hence 0*67 will be performed , which evaluates to 0.
        
        Array class or other wrapper classes like Number , String , Boolean ... do not define the 
        method [Symbol.toPrimitive](..) , but unlike them Date class does define it.

        5)  >>  let d = new Date()

            >>  d[Symbol.toPrimitive]("number")     // hint === "number"
                1658943131090                       // timestamp
            
            >>  d[Symbol.toPrimitive]("string")     // hint === "string"
                'Wed Jul 27 2022 23:02:11 GMT+0530 (India Standard Time)'

            >>  d[Symbol.toPrimitive]("default")    // hint === "default", treated same as hint === "string".
                'Wed Jul 27 2022 23:02:11 GMT+0530 (India Standard Time)'
            
        
    EXPLICIT CONVERSION
    -------------------

        We can use Number() , String() , Boolean() for explicit type conversion.

        >>  Number(null)        >>  Number("137")       >>  Number(true)
            0                       137                     1

        >>  Number("")          >>  Number(undefined)   >>  Number("$72.3")
            0                       NaN                     NaN

        >>  Number("54ABX")     >>  Number("-0.45")     >>  Number("  37  ")  // trailing spaces are ignored
            NaN                     -0.45                   37



        >>  String(54)          >>  String(undefined)   >>  String(false)   >>  String("already a string")
            "54"                    "undefined"             "false"             "already a string"    



        >>  Boolean(null)       >>  Boolean(-35.6)      >>  Boolean({})     >>  Boolean("")
            false                   true                    true                false


        
        >>  Number([])      //  ToPrimitive() will be called by Number() on [] with preferredType as "number".
            0               //  Array class does not define [Symbol.toPrimitive](..) , therefore ,
                            //  OrdinaryToPrimitive(..) will be called in turn with hint === "number."
                            //  OrdinaryToPrimitive(..) will call valueOf() on [] , which will return an
                            //  object reference i.e., not a primitive value. Therefore toString() will be 
                            //  called on [] next , which will return "" (empty string) i.e., a primitive.
                            //  Therefore OrdinaryToPrimitive(..) will return "" which in turn be returned
                            //  by ToPrimitive(..). 
                            //  Since "" is not a number , Number(..) will perform primitive-to-primitive 
                            //  conversion by passing "" to ToNumber() , which will convert it to 0.
                            //  Hence 0 will be returned.

        parseInt() and parseFloat()
        ```````````````````````````                    
            parseInt() and paseFloat() methods can also be used to parse string as a number. If a number
            is passed , it will be returned back. Parsing from left to right both of these methods will 
            skip any leading whitsepaces , parse as big valid numerical literal as they can and then 
            ignore anything that follows. 

                >>  pareseInt("35")         >>  parseFloat("-3.6")
                    35                      -3.6

                >>  parseInt("  34xbcd")    >>  parseFloat("35.6ff7xx")
                    34                          35.6

            If the leading non-space characters cannot be a part of a valid numerical literal , then they
            return NaN.

                >>  parseInt(" $73.6")          >>  parseInt("  --34")
                    NaN                             NaN

            parseInt(..) accepts an optional 2nd argument i.e., base (radix) of the number to be parsed.
            2 <= base <= 36.

                >>  parseInt("FF0A",16)     
                    65290

            When passed an object both will pass it to ToPrimitive(..) with preferredType === "string".

                >>  let ob = {
                        [Symbol.toPrimitive] : function(hint){
                            if(hint==="string")         return "30";
                            else if(hint==="number")    return 40;
                            else if(hint==="default")   return 50;
                        }
                    }

                >>  parseInt(ob)
                    30
            

    
    Number class also provide toString() method for converting wrapped numbers to string.
        >>  (56.78).toString()
            "56.78"

    toString() also takes an optional argument i.e., base (2<=base<=36) , using which we can get the 
    representation of our base-10 number in other bases.
        >>  (1025).toString(36)
            "sh"
