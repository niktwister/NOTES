LOGICAL OPERATORS
-----------------

    1)  a || b

        If 'a' is a truthy value , then returns 'a'.
            >>  5 || 0      >>  10 || 15
                5               10

        Otherwise if 'a' is falsy value , then it returns 'b'.
            >>  undefined || null       >>  null || 5
                null                        5                


    2)  a && b

        If 'a' is a truthy value , then returns 'b'.
            >>  5 && 0      >>  10 && 15
                0               15

        Otherwise if 'a' is falsy value , then it returns 'a'.
            >>  undefined && null       >>  null && 5
                undefined                   null                


    3)  !(a)

        If 'a' is truthy value =>   return false
        If 'a' is falsy value   =>  return true



PROPERTY ACCESS EXPRESSIONS
---------------------------

    Two syntax for property access :
        1)  Expression.identifier
        2)  Expression[identifier]

    1)  Expression.identifier
        Here Expression is evaluated first , and it should specify an object, identifier specifies the
        name of the desired property.
        The value of the property named by the identifier is looked up in the object, and becomes the
        overall value of the expression.

    2)  Expression[Expression]
        The Expression before "[" is evaluated first, and it specifies an object or an array. Then
        the Expression inside "[]" is evaluated and converted to a string. This 2nd expression specifies
        the name of the desired property or the index of the desired array element.

    EXAMPLES :

        >>  let b = {x:1 , y:{z:3}}
        >>  let a = [b,4,[5,6]]

        >>  b.x             >>  b.y.z
            1                   3

        >>  b['y']['z']     >>  a[1]        >>  a[2]['1']       >>  a[0]['x']
            3                   4               6                   1

        >>  b['y'].z        >>  b.y['z']
            3                   3

    When the expression before "." or "[" evaluates to either null or undefined, TypeError will be
    thrown. Because these are the only two values in JS that can't have properties, other primitive
    types such as number, string, boolean... will get wrapped around in their respective wrapper
    class objects before we try to access their property.

    Assuming that the expression before "." or "[" is neither null or undefined. Then if the property
    (of an object) or the index (of an array) we are trying to access doesn't exist, then the whole
    property access expression will evaluate to undefined.

    >>  null.abc            >>  'hi'.xyz    // String class has no property named 'xyz'
        TypeError               undefined

    >>  let arr = [1,5,7]
    >>  a[3]
        undefined

    >>  let ob = {name:"nik" , age:23}
    >>  ob["gender"]    //  non existent property
        undefined
    >>  ob.name.xyz     //  "nik".xyz is undefined
        undefined
    >>  ob.gender.xyz   //  ob.gender evaluates to undefined, undefined.xyz will will throw TypeError
        TypeError


    Drawbacks of Expression.identifier syntax are :
        1)  name of the property we are trying to access should be a legal identifier.
        2)  we should know the name while writing the program.

    

CONDITIONAL PROPERTY ACCESS (ES2020)
------------------------------------

    syntax :
        1)  expression?.identifier
        2)  epxression?.[expression]

    "?." -> optional chaining operator

    When sub-expression to the left of "?." is either null or undefined, then the evaulation of the
    whole expression is short circuited and the whole expression just evaluate to undefined, rather
    than throwing TypeError.

    NOTE :      .................................
                |   member access (.)           |
                |   computed member access ([]) |------>    All these operators have same precedence
                |   function call (())          |           and associativity (left to right).
                |   optional chaining (?.)      |
                `````````````````````````````````

    EXAMPLE :

        >>  let a = {b:null}
        >>  a.b?.c.d            //  a.b evaluates to null
            undefined           //  null?.c will short circuit the evaulation of whole expression
                                //  and the whole expression will just evaluate to undefined.
                                //  We would have got TypeError if null.c was evaluated instead.

        >>  let a = {b:{e:2}}
        >>  a.b?.c.d            //  a.b evaluates to {e:2}
            TypeError           //  {e:2}?.c will evaluate to undefined since there is no 'c' named 
                                //  property in {e:2}
                                //  undefined.d will evaluate to TypeError.
                                //
        >>  a?.['b']['c']       //  a?.['b'] evaluates to {e:2}
            undefined           //  {e:2}['c'] evaluates to undefined.


Invocation expression and conditional invocation expression
-----------------------------------------------------------
    
    <function-expression>(<comma separated list of 0 or more argument expressions>)

    <function-expression> is evaluated first and then the multiple <argument-expression>(s) (if any)
    are evaluated. If the called function doesn't return anything, the value of invocation expression
    evaluates to undefined.

    In case the <function-expression> evaluates to null, undefined, or any other non-function, a
    TypeError is thrown.

    So to avoid such TypeError to some degree, instead of using () for function invocation 
    we can use ?.() :
        <function-expression>?.(<comma separated list of 0 or more argument expressions>)
    If the expression to the left of ?. is null or undefined, the invocation will be short 
    circuited and the whole invocation expression will evaluate to undefined rather than a
    TypeError.

    >>  null()              >>  null?.()
        TypeError               undefined

    >>  undefined()         >> undefined?.()
        TypeError              undefined


    >>  let x = 5
    >>  x()             //  non-function
        TypeError

    >>  x?.()           //  ?.  will only short-circuit the whole expression, if and only if
        TypeError       //  the sub-expression to its left is either null or undefined.



OPERATOR PRECEDENCE IN JAVASCRIPT
---------------------------------

    precedence table : 
    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table

    lvalue :    lvalue is a historical term that means "an expression that can legally appear on the left
                side of an assignment expression" . In JS , variables , properties of object and elements
                of array are lvalues.


    Associativity : When two operations with same precedence shares an operand, then their associativity 
                    will decide which of the two will be performed first :
                        ->  If associativity is left-to-right , then operator to the left of operand will
                            be performed first and then the operator to the right of operand.
                        ->  If associativity is right-to-left, then operator to the right of operand will
                            be performed first and then the operator to the left of operand.

                    Example,  (+) and (-) have same precedence and associativity L->R i.e., left to right.
                    therefore the expression  10-5+5 will be equivalent to (10-5)+5 and not 10-(5+5).

    Expressions are always parsed  from left to right. Precedence only takes over when two operators
    with different precedence shares a common operand (conflict) , and associativity takes over when
    two operators with same precedence shares a common operand (conflict).

    EXAMPLE :
        consider the expression,   x = 4 + 5 - 3 * 2

        Since the expressions are parsed from left to right , we first encounter the operator (=) with
        operands (x) and (4). (=) shares a common operand with (+) operator i.e., (4). And since (+)
        has higher precendence than (=) , therefore (+) will be performed before (=). Now (+) also shares
        a common operand with (-) i.e., (5). Both (+) and (-) have same precedence and since their 
        associativity is left-to-right , therefore (+) will be performed before (-). After performing 
        (+) operation , the expression has now become:   x = 9 - 3 * 2
        Now once again parsing from left to right , (=) and (-) shares a common operand but precedence
        of (-) is > that of (=) hence (-) will be performed before (=). (-) also shares a common 
        operand with (*) which has higher precedence. Therefore (*) will be performed before (-).
        After performing (*) operation , the expression has now become: x = 9 - 6
        Again , since precedence of (-) is > precedence of (=) therefore (-) will be performed first.
        After performing (-) operation , the expression becomes: x = 3
        Now finally the assignment operation (=) will be performed , assigning the value (3) to (x).


        NOTE :  notice how (+) is performed before (*) , even though precedence of (*) > precedence of (+).
                This is because expression is being parsed from left to right , and they don't share a 
                common operand to create a conflict.



THE BINARY + OPERATOR
---------------------

    step 1) If either of the operand is an object, they will be converted to primitive by calling 
            ToPrimitive(...) w/o passing any preferredType.
    
    step2)  After both the operands are primitive, if either of the operand is a string the other
            is also converted to string (if not already) and concatenation is performed.

            Else, if neither of the operands are string, then they are both converted to number 
            (if not already) and added.

    >>  true + true     //  both primitive, neither string. Hence they are converted to number.
        2               //  true will become 1.
    
    >>  2 + null        //  both primitive, neither string. Hence they will be converted to number
        2               //  if required. null be converted to 0.

    >>  2 + undefined   //  both primitive, neither string. Hence they will be converted to number
        NaN             //  if required. Since undefined when converted to number get NaN, 
                        //  therefore we will get 2 + NaN i.e., NaN .

    >>  1 + {}              //  (+) calls ToPrimitive(..) for object {} with no preferredType.
        1[object Object]    //  Since no preferredType is provided, hint will be set to "default".
                        //  {} does not define any [Symbol.ToPrimitive](..) method, therefore
                        //  OrdinaryToPrimitive(..) will be called with hint==="number".
                        //  OrdinaryToPrimitive(..) will call valueOf() first, but it will return
                        //  a reference to {} itself i.e., a non-primitive value , therefore
                        //  toString() will be called next. toString() on {} will return the 
                        //  string "[object Object]" , which is primitive therefore it will be 
                        //  returned to ToPrimitive(..) , which in turn will return it to (+).
                        //  And now since one of the operand is a string , (+) will convert 1 to
                        //  string too i.e., "1" and we will get their concatenation i.e.,  
                        //  "1[object Object]" .


UNARY ARITHMETIC OPERATORS  (+,-,++,--)
---------------------------------------

    They all have right-to-left precedence.
    If operand is object then they will call ToPrimitive(..) with preferredType === "number".
    If ToPrimitive(..) doesn't return a primitive of type number, ToNumber(..) will be called
    for primitive-to-primitive conversion.

    unary plus (+)  :   converts the operand to number (if not already) as mentioned above (or to NaN) 
                        and returns the converted value. 

    unary minus (+)  :  converts the operand to number (if not already) as mentioned above (or to NaN) 
                        and change the sign of the result.

    increment (++)  :   The operand must be an lvalue.  
                        It converts the operand to a number, add 1 to it and assigns the incremented
                        value back to the variable/element/property.

                        The value returned depends on the relative position of (++) w.r.t operand :
                            ++operand   =>  incremented value is returned
                            operand++   =>  original value is returned

                        Also note that ++x is not always the same as x=x+1 :

                            >>  x = "1"         >>  x = "1"             
                            >>  x = x + 1       >>  ++x
                            >>  x                   2
                                "11"            >>  x
                                                    2



    decrement (--)  :   The operand must be an lvalue.  
                        It converts the operand to a number, subtract 1 from it and assigns the decremented
                        value back to the variable/element/property.

                        The value returned depends on the relative position of (--) w.r.t operand :
                            --operand   =>  decremented value is returned
                            operand--   =>  original value is returned


    EXAMPLE :

        >>  let a = [3]
        >>  --a             //  ToPrimitive(..) will be called for [3] with preferredType==="number"
            2               //  Array class doesn't define [Symbol.toPrimitive](..) method therefore
        >>  a               //  OrdinaryToPrimitive(..) will be called with hint === "number".
            2               //  OrdinaryToPrimitive(..) will first calle valueOf() on [3] , but Array
                            //  class doesn't override the valueOf() of the Object class , therefore 
                            //  a reference to the [3] will be returned i.e., not primitive. Therefore
                            //  toString() will be called on [3] , which will return "3" . Since its
                            //  primitive OrdinaryToPrimitive(..) will return "3" to ToPrimitive(..)
                            //  which in turn will return it to (--) . 
                            //  Now (--) will convert "3" to number by calling ToNumber(..) .
                            //  "3" will become 3 , and finally (--) will subtract one from it to get
                            //  2. 2 will be assigned to variable (a) and returned too.


BITWISE OPERATORS (~ , | , & , ^ , << , >> , >>>)
-------------------------------------------------

    They expect integer operands and behave as if the operand are 32-bit signed integers.

    They convert thir operands to number (if required).
    Exception : NaN , Infinity , -Infinity all converts to 0 when used as operands of bitwise operators.

    The range of 32-bit signed integer is :    [-2147483648 , +2147483647]
    If operand is an integer outside this range, it will wrap around this range.
    If operand is in binary, then any bit beyond the 32 least significant bits will be dropped.

    >>  (2147483647 + 1) | 0     
        -2147483648

    >>  (-2147483648 - 1) | 0
        2147483647

    >>  253.4 & -1      // fractional parts are dropped       
        253             //  -1 === 0xFFFFFFFF

    >>  0x1234 & 0x00FF     //  BITWISE AND
        52                  //  0x0034

    >>  0x1234 | 0x00FF     //  BITWISE OR
        4836                //  0x12FF

    >>  0xFF00 ^ 0xF0F0     //  BITWISE XOR
        4080                //  0x0FF0

    >>  ~0x0F               //  BITWISE NOT
        -16                 //  0xFFFFFFF0

    >>  0xFFF00000FF | 0x0  //  EXTRA BITS (BEYOND 32 LSb(s)) WILL BE DROPPED OFF FOR FIRST OPERAND
        -268435201          //  0xF00000FF

    
    Shift operations take two operands :    (32-bit signed int) [shift opr] (5-bit unsigned int)
                                                                                    |
                                                                                    V
                                                                    no of bits to shift (0<=x<=31)
    
    >>  7 << 2      //  Left shift
        28          //  MSb(s) are lost , 0s enter from right

    >>  28 >> 2     //  Right shift with sign preserved
                    //  LSb(s) are lost 
    >>  -1 >> 4     //  if (MSb === 0)  0s enter from left
        -1          //  if (MSb === 1)  1s enter from left  

    >>  -1 >>> 4    //  Right shift with zero fill
        268435455   //  LSb(s) are lost , 0s enter from left
                    //  0xFFFFFFFF >>> 4 => 0x0FFFFFFF
                    //      (-1)            (268435455)


STRICT EQUALITY (===)
---------------------
    https://262.ecma-international.org/13.0/#sec-isstrictlyequal

    1)  strict equality compares the two values as follows (no type conversion is performed):
            
            1.1) If two values have different types, they are not equal.

            1.2) If both values are null or if both values are undefined then, they are equal.

            1.3) If both values are true or if both values are false, they are equal.

            1.4) If one or both values is NaN, they are not equal.

            1.5) If both values are numbers and have same values, they are equal. +0 and -0 are equal.

            1.6) If both values are strings and contains exactly same sequence of 16-bit values, they
                 are equal.

            1.7) If both values refer to same object, they are equal. If both refer to different objects
                 (even if they're identical in properties), they are not equal.
        

EQUALITY WITH TYPE CONVERSION (==)
----------------------------------
    https://262.ecma-international.org/13.0/#sec-islooselyequal

    **bigint not taken into account. Check docs.

    1)  If the two values have same type, test them for strict equality. If they're strictly equal, they
        are equal. If they're not strictly equal, they are not equal.

    2)  If the two values have different tpyes, use the following rules :

            2.1) null and undefined are equal.

            2.2) If one value is a number and other a sring, convert the string to number and try again.

            2.3) If either value is a true, convert to 1 and compare again. If either value is a false,
                 convert it to 0 and compare again.

            2.4) If one value is an object and other is number/string, then convert the object to 
                 primtive and compare again.

            2.5) Any other combination of values are not equal.

    
    NOTE : (==) provides no preferredType to ToPrimitive(..) for object-to-primtive conversion.



->  !==     is NOT(STRICTLY EQUAL)
    !=      is NOT(LOOSELY EQUAL)

    for example, null and undefined are loosely equal but are not strictly equal.

    >>  null !== undefined
        true

    >>  null != undefined
        false



COMPARISION OPERATOR
--------------------

    https://262.ecma-international.org/13.0/#sec-islessthan

    **bigint not taken into account. Check docs.

    comparision can be performed only on numbers and strings, so operands that are not of type number
    or type string gets converted as follows :

        1)  If either of the operand is an object, convert it to primitive with preferredType==="number".
            Then compare again.
        
        2)  If after any required object-to-primitive conversion, both operands are string, we comapre them
            by comparing (numerically) the 16-bit values that make up those strings.

        3)  If after any required object-to-primitive conversion, atleast one of the operand is not a string,
            then both operands are converted to numbers and compared numerically.

    ->  +0 and -0 are considered equal.
        Infinity is larger than any number other than itself.
        -Infinity is smaller than any number other than itself.

    ->  If either operand is NaN or converts to NaN, comparision operators will return false.

    ->  comparision b/w numbers and bigint is allowed.

    ->  Its clear that comparision operators favor numbers over strings. They only perform string
        comparision when both operands are strings.

        Binary (+) on the other hand favor strings over numbers, it perform concatenation if either
        operand is a string.

            >>  "11" + 3        //  3 is converted to "3"
                "113"

            >>  "11" < 3        //  "11" is converted to 11.
                false

            >>  "one" < 3       //  "one" is converted to NaN.
                false           //  NaN < 3 evaluates to false.

    ->  <= is just  NOT(>) .
    ->  >=  is just NOT(<) .


in OPERATOR
-----------

    property in object
        |
        ------------------> string / symbol / value that can be converted to string

    returns true if the property can be found anywhere along the prototype chain of the object,
    else returns false.

    >>  let user = {
            name : "nik" ,
            id : 6080602 ,
            age : 23
        }

    >>  "name" in user
        true

    >>  toString in user
        true


instanceof OPERATOR
-------------------

                                    ob instanceof func    
                                    |               |
                    object ----------               ---------- constructor function

    
    returns true iff func.prototype exists in the prototype chain of ob , else returns false.


LOGICAL AND (&&)
----------------

    operand1 && operand2

    operand1 is evaluated first. If operand1 is falsy the, the whole expression must be falsy, therefore 
    && simply returns the falsy value of operand1 w/o evaluating operand2 (short circuiting).
    On the otherhand if operand1 is truthy, then the value of whole expression will depend upon the value
    of operand2 i.e., if operand2 is truthy the whole expression will be truthy and if operand2 is falsy
    the whole expression must be falsy. Therfore in case operand1 is truthy, && will simply returns the 
    evaluated value of operand2.

    example of short circuiting :
                (a===b) && stop();      // if (a) is not equal to (b) , stop() will not be called.
                                        // same as   if(a===b){stop()};


LOGICAL OR (||)
---------------

    operand1 || operand2

    If operand1 evaluates to truthy, operand2 will not be evaluated (circuiting) and || will return the 
    value of operand1.
    If operand1 evaluates to falsy, operand2 will be evaluated and || will simply return the value of
    operand2.

    one of the usage of || is to select first truthy value in a set of alternative :

        max = maxWidth || preferences.maxWidth || 500;     
            //  this is equivalent to :
            //  if(maxWidth){max = maxWidth}
            //  else if(preferences.maxWidth){max = maxWidth}
            //  else{max = 500;}
            //
            //  The usage of || this way will fall short if 0 is a valid value for maxWidth. Since 0
            //  is falsy.

    Prior to ES6 , || was used like above to provide default values to parameters in functions :

        function greet(name){
            
            name = name || "stranger";          //  if name is not passed to greet(..), name will become
                                                //  undefined. Since undefined is falsy value , therefore
            console.log(`Hello!! ${name}`);     //  (name || "stranger") will evaluate to "stranger", hence
                                                //  name will become "stranger".
        }                                       //  If a non-empty string name is passed to greet(..) ,  
                                                //  it will be truthy therefore (name || "stranger") will
                                                //  evaluate to whatever is passed in name.
    

    But starting from ES6 , we can specify the default value of a paramter in the function itself :

        function greet(name="stranger"){        //  If a default value is assigned to a paramter then, 
            ..                                  //  it should either be the rightmost parameter or 
        }                                       //  all the paramters to its right have also been assigned
                                                //  some default value.
                                                //
                                                //  This whole drama of assigning default values to 
                                                // paramters started since JS doesn't support overloading
                                                //  functions.


LOGICAL NOT (!)
---------------

    unlike && and || , ! will always evaluate to a boolean value true / false.

    ! operand
        | 
        |..... if operand is truthy, ! will return false.
        |
        |..... if operand is falsy, ! will return true.


FIRST DEFINED (??) (ES2020)
---------------------------

    operand1 ?? operand2

    evaluates the operand1. If its neither null or undefined, the value of operand1 is returned 
    without the evaluation of operand2 (short-circuiting).

    Else if operand1 evaluates to null or undefined, the operand2 is evaluated and returned.

    We saw before that || can be used to select the first truthy value as below : 
        max = maxWidth || preferences.maxWidth || 500;
    The problem with this approach is that all falsy values will be ignored. Falsy values like 0 ,
    "" , or false can be perfectly valid values in certain circumstances. So it makes sense to pick
    the first defined value (using ??) rather than the first truthy value (using ||) :
        max = maxWidth ?? preferences.maxWidth ?? 500;
    Now if maxWidth is 0, it will not be ignored.


    NOTE :  relative precedence of (??) with (&& , ||) is ambiguous. Therefore brackets should be 
            used when mixing (??) with (&& , ||) in an expression, or else we will get SyntaxError.

            >>  1 ?? 2 || 3
                SyntaxError
            
            >>  (1 ?? 2) || 3
                1
    
            >>  null ?? (2 && 3)
                3


delete OPERATOR
---------------

    delete operator is used to remove own-configurable property from an object.
    syntax :
        delete oject.property
        delete object["property"]

    return value
    ------------

        true is returned in following cases for both strict and non-strict mode :
            ->  After successfully deleting own configurable property.
            ->  If the property is non-existent.
            ->  After failing to delete not-own (inherited) property.
            ->  meaningless expression
        
        false is returned in following cases for non-strict mode , error is thrown in strict mode :
            ->  trying to delete own non-configurable property (TypeError in strict mode)
            ->  trying to delete a variable or a function (SyntaxError in strict mode)

    
    NOTE : variables (declared using var) and functions that are declared globally also becomes properties
            of the window object. But they still cannot be deleted using delete operator since they become
            non-configurable properties.

    NOTE :  delete operation has nothing to do with directly freeing memory. 
            We can have objects as properties too. When we delete such properties , we are simply removing
            their references from parent object. But as long as there exist another reference to them, they 
            will survive.


    Arrays are object too. Therefore we can delete array's element using delete.

        >>  let arr = [0,10,20,30]
        >>  arr
            (4) [0,10,20,30]
            {
                0       :   0,
                1       :   10,
                2       :   20,
                3       :   30,
                length  :   4
            }

        >>  delete arr[2]
            true
        
        >>  arr
            (4) [0,10,empty,30]     //  As we can see, deleteing an array element won't change it's length.
            {                       //  We are just left with a hole in our array.
                0       :   0,
                1       :   10,
                3       :   30,
                length  :   4
            }


typeof OPERATOR
---------------

    Takes a single operand, and returns its type.
    .........................................
    |   x                   |   typeof x    |
    `````````````````````````````````````````
    |   undefined           |   "undefined" |
    -----------------------------------------
    |   null                |   "object"    |   **legacy reasons.
    -----------------------------------------
    |   true/false          |   "boolean"   |
    -----------------------------------------
    |   any number of NaN   |   "number"    |
    -----------------------------------------
    |   any bigint          |   "bigint"    |
    -----------------------------------------
    |   any string          |   "string"    |
    -----------------------------------------
    |   any symbol          |   "symbol"    |
    -----------------------------------------
    |   any function        |   "function"  |
    -----------------------------------------
    |   any non-function    |   "object"    |
    |       object          |               |
    -----------------------------------------

    NOTE :  even though functions are also objects, typeof differentiate b/w function objects and 
            non-function objects.


void OPERATOR
-------------

    void operand

    It evaluates its operand, discard its value and return undefined.

    >>  let counter = 0;
    >>  const increment = () => void ++counter;
    >>  increment()
        undefined
    >>  counter
        1


comma OPERATOR
--------------

    operand1 , operand2

    (,) operator evaluates its left operand, then evaluates its right operand, and then returns the 
    value of its right operand.

    It has left-to-right associativity.

    >>  1,2
        2
    
    >>  let i,j,k;                 
    >>  i = 0 , j = 1 , k = 2       //  (=) has higher precedence than (,)
        2


