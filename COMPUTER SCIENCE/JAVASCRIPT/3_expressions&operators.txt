LOGICAL OPERATORS
-----------------

    1)  a || b

        If 'a' is a truthy value , then returns 'a'.
            >>  5 || 0      >>  10 || 15
                5               10

        Otherwise if 'a' is falsy value , then it returns 'b'.
            >>  undefined || null       >>  null || 5
                null                        5                


    2)  a && b

        If 'a' is a truthy value , then returns 'b'.
            >>  5 && 0      >>  10 && 15
                0               15

        Otherwise if 'a' is falsy value , then it returns 'a'.
            >>  undefined && null       >>  null && 5
                undefined                   null                


    3)  !(a)

        If 'a' is truthy value =>   return false
        If 'a' is falsy value   =>  return true



PROPERTY ACCESS EXPRESSIONS
---------------------------

    Two syntax for property access :
        1)  Expression.identifier
        2)  Expression[identifier]

    1)  Expression.identifier
        Here Expression is evaluated first , and it should specify an object, identifier specifies the
        name of the desired property.
        The value of the property named by the identifier is looked up in the object, and becomes the
        overall value of the expression.

    2)  Expression[Expression]
        The Expression before "[" is evaluated first, and it specifies an object or an array. Then
        the Expression inside "[]" is evaluated and converted to a string. This 2nd expression specifies
        the name of the desired property or the index of the desired array element.

    EXAMPLES :

        >>  let b = {x:1 , y:{z:3}}
        >>  let a = [b,4,[5,6]]

        >>  b.x             >>  b.y.z
            1                   3

        >>  b['y']['z']     >>  a[1]        >>  a[2]['1']       >>  a[0]['x']
            3                   4               6                   1

        >>  b['y'].z        >>  b.y['z']
            3                   3

    When the expression before "." or "[" evaluates to either null or undefined, TypeError will be
    thrown. Because these are the only two values in JS that can't have properties, other primitive
    types such as number, string, boolean... will get wrapped around in their respective wrapper
    class objects before we try to access their property.

    Assuming that the expression before "." or "[" is neither null or undefined. Then if the property
    (of an object) or the index (of an array) we are trying to access doesn't exist, then the whole
    property access expression will evaluate to undefined.

    >>  null.abc            >>  'hi'.xyz    // String class has no property named 'xyz'
        TypeError               undefined

    >>  let arr = [1,5,7]
    >>  a[3]
        undefined

    >>  let ob = {name:"nik" , age:23}
    >>  ob["gender"]    //  non existent property
        undefined
    >>  ob.name.xyz     //  "nik".xyz is undefined
        undefined
    >>  ob.gender.xyz   //  ob.gender evaluates to undefined, undefined.xyz will will throw TypeError
        TypeError


    Drawbacks of Expression.identifier syntax are :
        1)  name of the property we are trying to access should be a legal identifier.
        2)  we should know the name while writing the program.

    

CONDITIONAL PROPERTY ACCESS (ES2020)
------------------------------------

    syntax :
        1)  expression?.identifier
        2)  epxression?.[expression]

    "?." -> optional chaining operator

    When sub-expression to the left of "?." is either null or undefined, then the evaulation of the
    whole expression is short circuited and the whole expression just evaluate to undefined, rather
    than throwing TypeError.

    NOTE :      .................................
                |   member access (.)           |
                |   computed member access ([]) |------>    All these operators have same precedence
                |   function call (())          |           and associativity (left to right).
                |   optional chaining (?.)      |
                `````````````````````````````````

    EXAMPLE :

        >>  let a = {b:null}
        >>  a.b?.c.d            //  a.b evaluates to null
            undefined           //  null?.c will short circuit the evaulation of whole expression
                                //  and the whole expression will just evaluate to undefined.
                                //  We would have got TypeError if null.c was evaluated instead.

        >>  let a = {b:{e:2}}
        >>  a.b?.c.d            //  a.b evaluates to {e:2}
            TypeError           //  {e:2}?.c will evaluate to undefined since there is no 'c' named 
                                //  property in {e:2}
                                //  undefined.d will evaluate to TypeError.
                                //
        >>  a?.['b']['c']       //  a?.['b'] evaluates to {e:2}
            undefined           //  {e:2}['c'] evaluates to undefined.


Invocation expression and conditional invocation expression
-----------------------------------------------------------
    
    <function-expression>(<comma separated list of 0 or more argument expressions>)

    <function-expression> is evaluated first and then the multiple <argument-expression>(s) (if any)
    are evaluated. If the called function doesn't return anything, the value of invocation expression
    evaluates to undefined.

    In case the <function-expression> evaluates to null, undefined, or any other non-function, a
    TypeError is thrown.

    So to avoid such TypeError to some degree, instead of using () for function invocation 
    we can use ?.() :
        <function-expression>?.(<comma separated list of 0 or more argument expressions>)
    If the expression to the left of ?. is null or undefined, the invocation will be short 
    circuited and the whole invocation expression will evaluate to undefined rather than a
    TypeError.

    >>  null()              >>  null?.()
        TypeError               undefined

    >>  undefined()         >> undefined?.()
        TypeError              undefined


    >>  let x = 5
    >>  x()             //  non-function
        TypeError

    >>  x?.()           //  ?.  will only short-circuit the whole expression, if and only if
        TypeError       //  the sub-expression to its left is either null or undefined.



OPERATOR PRECEDENCE IN JAVASCRIPT
---------------------------------

    precedence table : 
    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table

    lvalue :    lvalue is a historical term that means "an expression that can legally appear on the left
                side of an assignment expression" . In JS , variables , properties of object and elements
                of array are lvalues.


    Associativity : When two operations with same precedence shares an operand, then their associativity 
                    will decide which of the two will be performed first :
                        ->  If associativity is left-to-right , then operator to the left of operand will
                            be performed first and then the operator to the right of operand.
                        ->  If associativity is right-to-left, then operator to the right of operand will
                            be performed first and then the operator to the left of operand.

                    Example,  (+) and (-) have same precedence and associativity L->R i.e., left to right.
                    therefore the expression  10-5+5 will be equivalent to (10-5)+5 and not 10-(5+5).

    Expressions are always parsed  from left to right. Precedence only takes over when two operators
    with different precedence shares a common operand (conflict) , and associativity takes over when
    two operators with same precedence shares a common operand (conflict).

    EXAMPLE :
        consider the expression,   x = 4 + 5 - 3 * 2

        Since the expressions are parsed from left to right , we first encounter the operator (=) with
        operands (x) and (4). (=) shares a common operand with (+) operator i.e., (4). And since (+)
        has higher precendence than (=) , therefore (+) will be performed before (=). Now (+) also shares
        a common operand with (-) i.e., (5). Both (+) and (-) have same precedence and since their 
        associativity is left-to-right , therefore (+) will be performed before (-). After performing 
        (+) operation , the expression has now become:   x = 9 - 3 * 2
        Now once again parsing from left to right , (=) and (-) shares a common operand but precedence
        of (-) is > that of (=) hence (-) will be performed before (=). (-) also shares a common 
        operand with (*) which has higher precedence. Therefore (*) will be performed before (-).
        After performing (*) operation , the expression has now become: x = 9 - 6
        Again , since precedence of (-) is > precedence of (=) therefore (-) will be performed first.
        After performing (-) operation , the expression becomes: x = 3
        Now finally the assignment operation (=) will be performed , assigning the value (3) to (x).


        NOTE :  notice how (+) is performed before (*) , even though precedence of (*) > precedence of (+).
                This is because expression is being parsed from left to right , and they don't share a 
                common operand to create a conflict.


